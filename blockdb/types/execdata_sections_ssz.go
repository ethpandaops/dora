// Code generated by dynamic-ssz. DO NOT EDIT.
// Hash: d3acce19a9e9c0afc0038f9dfd949d804d4b82beafef97cc4d618d03c202d4af
// Version: v1.2.1 (https://github.com/pk910/dynamic-ssz)
package types

import (
	"encoding/binary"

	dynssz "github.com/pk910/dynamic-ssz"
	"github.com/pk910/dynamic-ssz/hasher"
	"github.com/pk910/dynamic-ssz/sszutils"
)

var _ = sszutils.ErrListTooBig

func (t *ReceiptMetaData) MarshalSSZ() ([]byte, error) {
	return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}
func (t *ReceiptMetaData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	if t == nil {
		t = new(ReceiptMetaData)
	}
	{ // Field #0 'Version'
		dst = binary.LittleEndian.AppendUint16(dst, t.Version)
	}
	{ // Field #1 'Status'
		dst = append(dst, byte(t.Status))
	}
	{ // Field #2 'TxType'
		dst = append(dst, byte(t.TxType))
	}
	{ // Field #3 'CumulativeGasUsed'
		dst = binary.LittleEndian.AppendUint64(dst, t.CumulativeGasUsed)
	}
	{ // Field #4 'GasUsed'
		dst = binary.LittleEndian.AppendUint64(dst, t.GasUsed)
	}
	{ // Field #5 'EffectiveGasPrice'
		t := &t.EffectiveGasPrice
		for i := range 4 {
			dst = binary.LittleEndian.AppendUint64(dst, t[i])
		}
	}
	{ // Field #6 'BlobGasUsed'
		dst = binary.LittleEndian.AppendUint64(dst, t.BlobGasUsed)
	}
	{ // Field #7 'LogsBloom'
		dst = append(dst, t.LogsBloom[:256]...)
	}
	{ // Field #8 'From'
		dst = append(dst, t.From[:20]...)
	}
	{ // Field #9 'To'
		dst = append(dst, t.To[:20]...)
	}
	{ // Field #10 'ContractAddress'
		dst = append(dst, t.ContractAddress[:20]...)
	}
	{ // Field #11 'HasContractAddr'
		dst = sszutils.MarshalBool(dst, t.HasContractAddr)
	}
	return dst, nil
}

func (t *ReceiptMetaData) UnmarshalSSZ(buf []byte) (err error) {
	buflen := len(buf)
	if buflen < 377 {
		return sszutils.ErrUnexpectedEOF
	}
	{ // Field #0 'Version' (static)
		buf := buf[0:2]
		t.Version = binary.LittleEndian.Uint16(buf)
	}
	{ // Field #1 'Status' (static)
		buf := buf[2:3]
		t.Status = buf[0]
	}
	{ // Field #2 'TxType' (static)
		buf := buf[3:4]
		t.TxType = buf[0]
	}
	{ // Field #3 'CumulativeGasUsed' (static)
		buf := buf[4:12]
		t.CumulativeGasUsed = binary.LittleEndian.Uint64(buf)
	}
	{ // Field #4 'GasUsed' (static)
		buf := buf[12:20]
		t.GasUsed = binary.LittleEndian.Uint64(buf)
	}
	{ // Field #5 'EffectiveGasPrice' (static)
		buf := buf[20:52]
		val1 := t.EffectiveGasPrice
		for i := range 4 {
			buf := buf[8*i : 8*(i+1)]
			val1[i] = binary.LittleEndian.Uint64(buf)
		}
		t.EffectiveGasPrice = val1
	}
	{ // Field #6 'BlobGasUsed' (static)
		buf := buf[52:60]
		t.BlobGasUsed = binary.LittleEndian.Uint64(buf)
	}
	{ // Field #7 'LogsBloom' (static)
		buf := buf[60:316]
		copy(t.LogsBloom[:], buf)
	}
	{ // Field #8 'From' (static)
		buf := buf[316:336]
		copy(t.From[:], buf)
	}
	{ // Field #9 'To' (static)
		buf := buf[336:356]
		copy(t.To[:], buf)
	}
	{ // Field #10 'ContractAddress' (static)
		buf := buf[356:376]
		copy(t.ContractAddress[:], buf)
	}
	{ // Field #11 'HasContractAddr' (static)
		buf := buf[376:377]
		if buf[0] != 1 && buf[0] != 0 {
			return sszutils.ErrInvalidValueRange
		}
		t.HasContractAddr = buf[0] == 1
	}
	return nil
}

func (t *ReceiptMetaData) SizeSSZ() (size int) {
	return 377
}

func (t *ReceiptMetaData) HashTreeRoot() (root [32]byte, err error) {
	err = hasher.WithDefaultHasher(func(hh sszutils.HashWalker) (err error) {
		err = t.HashTreeRootWith(hh)
		if err == nil {
			root, err = hh.HashRoot()
		}
		return
	})
	return
}
func (t *ReceiptMetaData) HashTreeRootWith(hh sszutils.HashWalker) error {
	if t == nil {
		t = new(ReceiptMetaData)
	}
	idx := hh.Index()
	{ // Field #0 'Version'
		hh.PutUint16(t.Version)
	}
	{ // Field #1 'Status'
		hh.PutUint8(t.Status)
	}
	{ // Field #2 'TxType'
		hh.PutUint8(t.TxType)
	}
	{ // Field #3 'CumulativeGasUsed'
		hh.PutUint64(t.CumulativeGasUsed)
	}
	{ // Field #4 'GasUsed'
		hh.PutUint64(t.GasUsed)
	}
	{ // Field #5 'EffectiveGasPrice'
		t := &t.EffectiveGasPrice
		if root, err := t.HashTreeRoot(); err != nil {
			return err
		} else {
			hh.AppendBytes32(root[:])
		}
	}
	{ // Field #6 'BlobGasUsed'
		hh.PutUint64(t.BlobGasUsed)
	}
	{ // Field #7 'LogsBloom'
		hh.PutBytes(t.LogsBloom[:256])
	}
	{ // Field #8 'From'
		hh.PutBytes(t.From[:20])
	}
	{ // Field #9 'To'
		hh.PutBytes(t.To[:20])
	}
	{ // Field #10 'ContractAddress'
		hh.PutBytes(t.ContractAddress[:20])
	}
	{ // Field #11 'HasContractAddr'
		hh.PutBool(t.HasContractAddr)
	}
	hh.Merkleize(idx)
	return nil
}

func (t *BlockReceiptMeta) MarshalSSZ() ([]byte, error) {
	return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}
func (t *BlockReceiptMeta) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	if t == nil {
		t = new(BlockReceiptMeta)
	}
	{ // Field #0 'Version'
		dst = binary.LittleEndian.AppendUint16(dst, t.Version)
	}
	{ // Field #1 'BlobGasPrice'
		dst = binary.LittleEndian.AppendUint64(dst, t.BlobGasPrice)
	}
	return dst, nil
}

func (t *BlockReceiptMeta) UnmarshalSSZ(buf []byte) (err error) {
	buflen := len(buf)
	if buflen < 10 {
		return sszutils.ErrUnexpectedEOF
	}
	{ // Field #0 'Version' (static)
		buf := buf[0:2]
		t.Version = binary.LittleEndian.Uint16(buf)
	}
	{ // Field #1 'BlobGasPrice' (static)
		buf := buf[2:10]
		t.BlobGasPrice = binary.LittleEndian.Uint64(buf)
	}
	return nil
}

func (t *BlockReceiptMeta) SizeSSZ() (size int) {
	return 10
}

func (t *BlockReceiptMeta) HashTreeRoot() (root [32]byte, err error) {
	err = hasher.WithDefaultHasher(func(hh sszutils.HashWalker) (err error) {
		err = t.HashTreeRootWith(hh)
		if err == nil {
			root, err = hh.HashRoot()
		}
		return
	})
	return
}
func (t *BlockReceiptMeta) HashTreeRootWith(hh sszutils.HashWalker) error {
	if t == nil {
		t = new(BlockReceiptMeta)
	}
	idx := hh.Index()
	{ // Field #0 'Version'
		hh.PutUint16(t.Version)
	}
	{ // Field #1 'BlobGasPrice'
		hh.PutUint64(t.BlobGasPrice)
	}
	hh.Merkleize(idx)
	return nil
}

func (t *StateChangeAccount) MarshalSSZ() ([]byte, error) {
	return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}
func (t *StateChangeAccount) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	if t == nil {
		t = new(StateChangeAccount)
	}
	dstlen := len(dst)
	{ // Field #0 'Address'
		dst = append(dst, t.Address[:20]...)
	}
	{ // Field #1 'Flags'
		dst = append(dst, byte(t.Flags))
	}
	{ // Field #2 'PreBalance'
		t := &t.PreBalance
		for i := range 4 {
			dst = binary.LittleEndian.AppendUint64(dst, t[i])
		}
	}
	{ // Field #3 'PostBalance'
		t := &t.PostBalance
		for i := range 4 {
			dst = binary.LittleEndian.AppendUint64(dst, t[i])
		}
	}
	{ // Field #4 'PreNonce'
		dst = binary.LittleEndian.AppendUint64(dst, t.PreNonce)
	}
	{ // Field #5 'PostNonce'
		dst = binary.LittleEndian.AppendUint64(dst, t.PostNonce)
	}
	// Offset #6 'PreCode'
	offset6 := len(dst)
	dst = append(dst, 0, 0, 0, 0)
	// Offset #7 'PostCode'
	offset7 := len(dst)
	dst = append(dst, 0, 0, 0, 0)
	// Offset #8 'Slots'
	offset8 := len(dst)
	dst = append(dst, 0, 0, 0, 0)
	{ // Dynamic Field #6 'PreCode'
		binary.LittleEndian.PutUint32(dst[offset6:], uint32(len(dst)-dstlen))
		dst = append(dst, t.PreCode[:]...)
	}
	{ // Dynamic Field #7 'PostCode'
		binary.LittleEndian.PutUint32(dst[offset7:], uint32(len(dst)-dstlen))
		dst = append(dst, t.PostCode[:]...)
	}
	{ // Dynamic Field #8 'Slots'
		binary.LittleEndian.PutUint32(dst[offset8:], uint32(len(dst)-dstlen))
		t := t.Slots
		vlen := len(t)
		for i := range vlen {
			t := &t[i]
			{ // Field #0 'Slot'
				dst = append(dst, t.Slot[:32]...)
			}
			{ // Field #1 'PreValue'
				dst = append(dst, t.PreValue[:32]...)
			}
			{ // Field #2 'PostValue'
				dst = append(dst, t.PostValue[:32]...)
			}
		}
	}
	return dst, nil
}

func (t *StateChangeAccount) UnmarshalSSZ(buf []byte) (err error) {
	buflen := len(buf)
	if buflen < 113 {
		return sszutils.ErrUnexpectedEOF
	}
	{ // Field #0 'Address' (static)
		buf := buf[0:20]
		copy(t.Address[:], buf)
	}
	{ // Field #1 'Flags' (static)
		buf := buf[20:21]
		t.Flags = buf[0]
	}
	{ // Field #2 'PreBalance' (static)
		buf := buf[21:53]
		val1 := t.PreBalance
		for i := range 4 {
			buf := buf[8*i : 8*(i+1)]
			val1[i] = binary.LittleEndian.Uint64(buf)
		}
		t.PreBalance = val1
	}
	{ // Field #3 'PostBalance' (static)
		buf := buf[53:85]
		val2 := t.PostBalance
		for i := range 4 {
			buf := buf[8*i : 8*(i+1)]
			val2[i] = binary.LittleEndian.Uint64(buf)
		}
		t.PostBalance = val2
	}
	{ // Field #4 'PreNonce' (static)
		buf := buf[85:93]
		t.PreNonce = binary.LittleEndian.Uint64(buf)
	}
	{ // Field #5 'PostNonce' (static)
		buf := buf[93:101]
		t.PostNonce = binary.LittleEndian.Uint64(buf)
	}
	// Field #6 'PreCode' (offset)
	offset6 := int(binary.LittleEndian.Uint32(buf[101:105]))
	if offset6 != 113 {
		return sszutils.ErrOffset
	}
	// Field #7 'PostCode' (offset)
	offset7 := int(binary.LittleEndian.Uint32(buf[105:109]))
	if offset7 < offset6 || offset7 > buflen {
		return sszutils.ErrOffset
	}
	// Field #8 'Slots' (offset)
	offset8 := int(binary.LittleEndian.Uint32(buf[109:113]))
	if offset8 < offset7 || offset8 > buflen {
		return sszutils.ErrOffset
	}
	{ // Field #6 'PreCode' (dynamic)
		buf := buf[offset6:offset7]
		t.PreCode = sszutils.ExpandSlice(t.PreCode, len(buf))
		copy(t.PreCode[:], buf)
	}
	{ // Field #7 'PostCode' (dynamic)
		buf := buf[offset7:offset8]
		t.PostCode = sszutils.ExpandSlice(t.PostCode, len(buf))
		copy(t.PostCode[:], buf)
	}
	{ // Field #8 'Slots' (dynamic)
		buf := buf[offset8:]
		val3 := t.Slots
		itemCount := len(buf) / 96
		if len(buf)%96 != 0 {
			return sszutils.ErrUnexpectedEOF
		}
		val3 = sszutils.ExpandSlice(val3, itemCount)
		for i := range itemCount {
			val4 := val3[i]
			buf := buf[96*i : 96*(i+1)]
			buflen := len(buf)
			if buflen < 96 {
				return sszutils.ErrUnexpectedEOF
			}
			{ // Field #0 'Slot' (static)
				buf := buf[0:32]
				copy(val4.Slot[:], buf)
			}
			{ // Field #1 'PreValue' (static)
				buf := buf[32:64]
				copy(val4.PreValue[:], buf)
			}
			{ // Field #2 'PostValue' (static)
				buf := buf[64:96]
				copy(val4.PostValue[:], buf)
			}
			val3[i] = val4
		}
		t.Slots = val3
	}
	return nil
}

func (t *StateChangeAccount) SizeSSZ() (size int) {
	if t == nil {
		t = new(StateChangeAccount)
	}
	// Field #0 'Address' static (20 bytes)
	// Field #1 'Flags' static (1 bytes)
	// Field #2 'PreBalance' static (32 bytes)
	// Field #3 'PostBalance' static (32 bytes)
	// Field #4 'PreNonce' static (8 bytes)
	// Field #5 'PostNonce' static (8 bytes)
	// Field #6 'PreCode' offset (4 bytes)
	// Field #7 'PostCode' offset (4 bytes)
	// Field #8 'Slots' offset (4 bytes)
	size += 113
	{ // Dynamic field #6 'PreCode'
		size += len(t.PreCode)
	}
	{ // Dynamic field #7 'PostCode'
		size += len(t.PostCode)
	}
	{ // Dynamic field #8 'Slots'
		size += len(t.Slots) * 96
	}
	return size
}

func (t *StateChangeAccount) HashTreeRoot() (root [32]byte, err error) {
	err = hasher.WithDefaultHasher(func(hh sszutils.HashWalker) (err error) {
		err = t.HashTreeRootWith(hh)
		if err == nil {
			root, err = hh.HashRoot()
		}
		return
	})
	return
}
func (t *StateChangeAccount) HashTreeRootWith(hh sszutils.HashWalker) error {
	if t == nil {
		t = new(StateChangeAccount)
	}
	idx := hh.Index()
	{ // Field #0 'Address'
		hh.PutBytes(t.Address[:20])
	}
	{ // Field #1 'Flags'
		hh.PutUint8(t.Flags)
	}
	{ // Field #2 'PreBalance'
		t := &t.PreBalance
		if root, err := t.HashTreeRoot(); err != nil {
			return err
		} else {
			hh.AppendBytes32(root[:])
		}
	}
	{ // Field #3 'PostBalance'
		t := &t.PostBalance
		if root, err := t.HashTreeRoot(); err != nil {
			return err
		} else {
			hh.AppendBytes32(root[:])
		}
	}
	{ // Field #4 'PreNonce'
		hh.PutUint64(t.PreNonce)
	}
	{ // Field #5 'PostNonce'
		hh.PutUint64(t.PostNonce)
	}
	{ // Field #6 'PreCode'
		idx := hh.Index()
		hh.AppendBytes32(t.PreCode[:])
		hh.Merkleize(idx)
	}
	{ // Field #7 'PostCode'
		idx := hh.Index()
		hh.AppendBytes32(t.PostCode[:])
		hh.Merkleize(idx)
	}
	{ // Field #8 'Slots'
		t := t.Slots
		idx := hh.Index()
		vlen := uint64(len(t))
		for i := range int(vlen) {
			t := &t[i]
			idx := hh.Index()
			{ // Field #0 'Slot'
				hh.PutBytes(t.Slot[:32])
			}
			{ // Field #1 'PreValue'
				hh.PutBytes(t.PreValue[:32])
			}
			{ // Field #2 'PostValue'
				hh.PutBytes(t.PostValue[:32])
			}
			hh.Merkleize(idx)
		}
		hh.Merkleize(idx)
	}
	hh.Merkleize(idx)
	return nil
}

func (t *FlatCallFrame) MarshalSSZ() ([]byte, error) {
	return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}
func (t *FlatCallFrame) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	if t == nil {
		t = new(FlatCallFrame)
	}
	dstlen := len(dst)
	{ // Field #0 'Depth'
		dst = binary.LittleEndian.AppendUint16(dst, t.Depth)
	}
	{ // Field #1 'Type'
		dst = append(dst, byte(t.Type))
	}
	{ // Field #2 'From'
		dst = append(dst, t.From[:20]...)
	}
	{ // Field #3 'To'
		dst = append(dst, t.To[:20]...)
	}
	{ // Field #4 'Value'
		t := &t.Value
		for i := range 4 {
			dst = binary.LittleEndian.AppendUint64(dst, t[i])
		}
	}
	{ // Field #5 'Gas'
		dst = binary.LittleEndian.AppendUint64(dst, t.Gas)
	}
	{ // Field #6 'GasUsed'
		dst = binary.LittleEndian.AppendUint64(dst, t.GasUsed)
	}
	{ // Field #7 'Status'
		dst = append(dst, byte(t.Status))
	}
	// Offset #8 'Input'
	offset8 := len(dst)
	dst = append(dst, 0, 0, 0, 0)
	// Offset #9 'Output'
	offset9 := len(dst)
	dst = append(dst, 0, 0, 0, 0)
	// Offset #10 'Error'
	offset10 := len(dst)
	dst = append(dst, 0, 0, 0, 0)
	{ // Dynamic Field #8 'Input'
		binary.LittleEndian.PutUint32(dst[offset8:], uint32(len(dst)-dstlen))
		dst = append(dst, t.Input[:]...)
	}
	{ // Dynamic Field #9 'Output'
		binary.LittleEndian.PutUint32(dst[offset9:], uint32(len(dst)-dstlen))
		dst = append(dst, t.Output[:]...)
	}
	{ // Dynamic Field #10 'Error'
		binary.LittleEndian.PutUint32(dst[offset10:], uint32(len(dst)-dstlen))
		dst = append(dst, t.Error[:]...)
	}
	return dst, nil
}

func (t *FlatCallFrame) UnmarshalSSZ(buf []byte) (err error) {
	buflen := len(buf)
	if buflen < 104 {
		return sszutils.ErrUnexpectedEOF
	}
	{ // Field #0 'Depth' (static)
		buf := buf[0:2]
		t.Depth = binary.LittleEndian.Uint16(buf)
	}
	{ // Field #1 'Type' (static)
		buf := buf[2:3]
		t.Type = buf[0]
	}
	{ // Field #2 'From' (static)
		buf := buf[3:23]
		copy(t.From[:], buf)
	}
	{ // Field #3 'To' (static)
		buf := buf[23:43]
		copy(t.To[:], buf)
	}
	{ // Field #4 'Value' (static)
		buf := buf[43:75]
		val1 := t.Value
		for i := range 4 {
			buf := buf[8*i : 8*(i+1)]
			val1[i] = binary.LittleEndian.Uint64(buf)
		}
		t.Value = val1
	}
	{ // Field #5 'Gas' (static)
		buf := buf[75:83]
		t.Gas = binary.LittleEndian.Uint64(buf)
	}
	{ // Field #6 'GasUsed' (static)
		buf := buf[83:91]
		t.GasUsed = binary.LittleEndian.Uint64(buf)
	}
	{ // Field #7 'Status' (static)
		buf := buf[91:92]
		t.Status = buf[0]
	}
	// Field #8 'Input' (offset)
	offset8 := int(binary.LittleEndian.Uint32(buf[92:96]))
	if offset8 != 104 {
		return sszutils.ErrOffset
	}
	// Field #9 'Output' (offset)
	offset9 := int(binary.LittleEndian.Uint32(buf[96:100]))
	if offset9 < offset8 || offset9 > buflen {
		return sszutils.ErrOffset
	}
	// Field #10 'Error' (offset)
	offset10 := int(binary.LittleEndian.Uint32(buf[100:104]))
	if offset10 < offset9 || offset10 > buflen {
		return sszutils.ErrOffset
	}
	{ // Field #8 'Input' (dynamic)
		buf := buf[offset8:offset9]
		t.Input = sszutils.ExpandSlice(t.Input, len(buf))
		copy(t.Input[:], buf)
	}
	{ // Field #9 'Output' (dynamic)
		buf := buf[offset9:offset10]
		t.Output = sszutils.ExpandSlice(t.Output, len(buf))
		copy(t.Output[:], buf)
	}
	{ // Field #10 'Error' (dynamic)
		buf := buf[offset10:]
		t.Error = string(buf)
	}
	return nil
}

func (t *FlatCallFrame) SizeSSZ() (size int) {
	if t == nil {
		t = new(FlatCallFrame)
	}
	// Field #0 'Depth' static (2 bytes)
	// Field #1 'Type' static (1 bytes)
	// Field #2 'From' static (20 bytes)
	// Field #3 'To' static (20 bytes)
	// Field #4 'Value' static (32 bytes)
	// Field #5 'Gas' static (8 bytes)
	// Field #6 'GasUsed' static (8 bytes)
	// Field #7 'Status' static (1 bytes)
	// Field #8 'Input' offset (4 bytes)
	// Field #9 'Output' offset (4 bytes)
	// Field #10 'Error' offset (4 bytes)
	size += 104
	{ // Dynamic field #8 'Input'
		size += len(t.Input)
	}
	{ // Dynamic field #9 'Output'
		size += len(t.Output)
	}
	{ // Dynamic field #10 'Error'
		size += len(t.Error)
	}
	return size
}

func (t *FlatCallFrame) HashTreeRoot() (root [32]byte, err error) {
	err = hasher.WithDefaultHasher(func(hh sszutils.HashWalker) (err error) {
		err = t.HashTreeRootWith(hh)
		if err == nil {
			root, err = hh.HashRoot()
		}
		return
	})
	return
}
func (t *FlatCallFrame) HashTreeRootWith(hh sszutils.HashWalker) error {
	if t == nil {
		t = new(FlatCallFrame)
	}
	idx := hh.Index()
	{ // Field #0 'Depth'
		hh.PutUint16(t.Depth)
	}
	{ // Field #1 'Type'
		hh.PutUint8(t.Type)
	}
	{ // Field #2 'From'
		hh.PutBytes(t.From[:20])
	}
	{ // Field #3 'To'
		hh.PutBytes(t.To[:20])
	}
	{ // Field #4 'Value'
		t := &t.Value
		if root, err := t.HashTreeRoot(); err != nil {
			return err
		} else {
			hh.AppendBytes32(root[:])
		}
	}
	{ // Field #5 'Gas'
		hh.PutUint64(t.Gas)
	}
	{ // Field #6 'GasUsed'
		hh.PutUint64(t.GasUsed)
	}
	{ // Field #7 'Status'
		hh.PutUint8(t.Status)
	}
	{ // Field #8 'Input'
		idx := hh.Index()
		hh.AppendBytes32(t.Input[:])
		hh.Merkleize(idx)
	}
	{ // Field #9 'Output'
		idx := hh.Index()
		hh.AppendBytes32(t.Output[:])
		hh.Merkleize(idx)
	}
	{ // Field #10 'Error'
		idx := hh.Index()
		hh.AppendBytes32([]byte(t.Error))
		hh.Merkleize(idx)
	}
	hh.Merkleize(idx)
	return nil
}

func (t *EventData) MarshalSSZ() ([]byte, error) {
	return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}
func (t *EventData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	if t == nil {
		t = new(EventData)
	}
	dstlen := len(dst)
	{ // Field #0 'EventIndex'
		dst = binary.LittleEndian.AppendUint32(dst, t.EventIndex)
	}
	{ // Field #1 'Source'
		dst = append(dst, t.Source[:20]...)
	}
	// Offset #2 'Topics'
	offset2 := len(dst)
	dst = append(dst, 0, 0, 0, 0)
	// Offset #3 'Data'
	offset3 := len(dst)
	dst = append(dst, 0, 0, 0, 0)
	{ // Dynamic Field #2 'Topics'
		binary.LittleEndian.PutUint32(dst[offset2:], uint32(len(dst)-dstlen))
		t := t.Topics
		vlen := len(t)
		if vlen > 5 {
			return nil, sszutils.ErrListTooBig
		}
		for i := range vlen {
			vlen := len(t[i])
			if vlen > 32 {
				return nil, sszutils.ErrVectorLength
			}
			dst = append(dst, t[i][:vlen]...)
			if vlen < 32 {
				dst = sszutils.AppendZeroPadding(dst, (32-vlen)*1)
			}
		}
	}
	{ // Dynamic Field #3 'Data'
		binary.LittleEndian.PutUint32(dst[offset3:], uint32(len(dst)-dstlen))
		dst = append(dst, t.Data[:]...)
	}
	return dst, nil
}

func (t *EventData) UnmarshalSSZ(buf []byte) (err error) {
	buflen := len(buf)
	if buflen < 32 {
		return sszutils.ErrUnexpectedEOF
	}
	{ // Field #0 'EventIndex' (static)
		buf := buf[0:4]
		t.EventIndex = binary.LittleEndian.Uint32(buf)
	}
	{ // Field #1 'Source' (static)
		buf := buf[4:24]
		copy(t.Source[:], buf)
	}
	// Field #2 'Topics' (offset)
	offset2 := int(binary.LittleEndian.Uint32(buf[24:28]))
	if offset2 != 32 {
		return sszutils.ErrOffset
	}
	// Field #3 'Data' (offset)
	offset3 := int(binary.LittleEndian.Uint32(buf[28:32]))
	if offset3 < offset2 || offset3 > buflen {
		return sszutils.ErrOffset
	}
	{ // Field #2 'Topics' (dynamic)
		buf := buf[offset2:offset3]
		val1 := t.Topics
		itemCount := len(buf) / 32
		if len(buf)%32 != 0 {
			return sszutils.ErrUnexpectedEOF
		}
		val1 = sszutils.ExpandSlice(val1, itemCount)
		for i := range itemCount {
			buf := buf[32*i : 32*(i+1)]
			val1[i] = sszutils.ExpandSlice(val1[i], 32)
			copy(val1[i][:], buf)
		}
		t.Topics = val1
	}
	{ // Field #3 'Data' (dynamic)
		buf := buf[offset3:]
		t.Data = sszutils.ExpandSlice(t.Data, len(buf))
		copy(t.Data[:], buf)
	}
	return nil
}

func (t *EventData) SizeSSZ() (size int) {
	if t == nil {
		t = new(EventData)
	}
	// Field #0 'EventIndex' static (4 bytes)
	// Field #1 'Source' static (20 bytes)
	// Field #2 'Topics' offset (4 bytes)
	// Field #3 'Data' offset (4 bytes)
	size += 32
	{ // Dynamic field #2 'Topics'
		size += len(t.Topics) * 32
	}
	{ // Dynamic field #3 'Data'
		size += len(t.Data)
	}
	return size
}

func (t *EventData) HashTreeRoot() (root [32]byte, err error) {
	err = hasher.WithDefaultHasher(func(hh sszutils.HashWalker) (err error) {
		err = t.HashTreeRootWith(hh)
		if err == nil {
			root, err = hh.HashRoot()
		}
		return
	})
	return
}
func (t *EventData) HashTreeRootWith(hh sszutils.HashWalker) error {
	if t == nil {
		t = new(EventData)
	}
	idx := hh.Index()
	{ // Field #0 'EventIndex'
		hh.PutUint32(t.EventIndex)
	}
	{ // Field #1 'Source'
		hh.PutBytes(t.Source[:20])
	}
	{ // Field #2 'Topics'
		t := t.Topics
		vlen := uint64(len(t))
		if vlen > 5 {
			return sszutils.ErrListTooBig
		}
		idx := hh.Index()
		for i := range int(vlen) {
			vlen := len(t[i])
			if vlen > 32 {
				return sszutils.ErrVectorLength
			}
			val := t[i][:]
			if vlen < 32 {
				val = sszutils.AppendZeroPadding(val, (32-vlen)*1)
			}
			hh.PutBytes(val[:32])
		}
		hh.MerkleizeWithMixin(idx, vlen, sszutils.CalculateLimit(5, vlen, 32))
	}
	{ // Field #3 'Data'
		idx := hh.Index()
		hh.AppendBytes32(t.Data[:])
		hh.Merkleize(idx)
	}
	hh.Merkleize(idx)
	return nil
}
